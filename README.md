# Общие требования к прошивке

### Общее описание:
Требуется прошивка для системы устройств, состоящей из сканера RFID меток (через COM-port) и шлагбаума. Также прошивка должна иметь возможность отправлять и принимать HTTP запросы на/от ниже описанных endpoint-в. Краткое описание деятельности системы: сканер RFID меток сканирует метку, дальше информация от сканера должна поступать на сервер для проверки валидности данной RFID метки, поступать через HTTP запрос в качестве event. При успешном выполнении запроса прошивка должна открывать шлагбаум и пропускать машину, которая приехала на территорию. Также существуют негативные кейсы, например отсутствие RFID метки в базе данных на сервере или неисправность шлагбаума и тд. Для случаев критической неисправности каких то устройств в системе существует endpoint "/api/report", в который можно сообщить какое устройство вышло из строя.

![wewwwewe](https://user-images.githubusercontent.com/71149808/130666489-4354306e-6d53-4ee1-bc1f-bbb209ed042f.png)


### Необходимые требования:
1. Возможность тестировать функциональность прошивки локально с адресом платы localhost:8181 (или в качестве аргументов при запуске самостоятельно передавать host и port)
2. В случае если плата переживает экстренное выключение питания и программа приостанавливается, желательно посылать в "/api/report" ID устройства.


# Документация к API

### Регистрация платы внутри программы - `POST /api/registration` - запрос с платы на сервер
Метод предназначенный для регистрации платы в нашей программе для дальнейшей идентификации плат и подконтрольных им устройств во время работы. Внутри платы должен быть флажок, что плата зарегистрирована, и плата должна совершать запросы на сервер до тех пор, пока не зарегистрируется успешно. В ответ на запрос будет прислано число, которое ядро должно запомнить. Это число будет означать номер, который backend присвоит для данной группы, ответ также будет дан в формате JSON. Может существовать кейс, в ходе которого какое-то из устройств не будет отвечать на позывные от ядра, в этом случае, ядро должно продолжить опрашивать это устройство и при этом зарегистрировать уже найденные устройства. Как только отсутствующее устройство откликнется, нужно сделать новый запрос на регистрацию включив в массив новое устройство (но не исключая уже зарегистрированные). 

![ErrorRegister](https://user-images.githubusercontent.com/71149808/130667622-c3494e9a-94db-49a1-aeec-cfb6e6914d04.png)
![ReRegister](https://user-images.githubusercontent.com/71149808/130667670-8fdfbe6c-01a8-4f4e-bc5b-e4ecad13fef0.png)

**Список параметров:**
`@RequestBody BoardRegisterDto` - объект, содержащий 3 поля:
http_address - адрес платы, в строчном формате, например "http://192.168.0.100:8080",
device_id - идентификатор устройства,
coordinates - координаты платы в формате строки: "55.993651, 37.183600"

**Формат запроса:**
```
{
     "group": число в формате long, при первой регистрации null
     "address" :  "192.168.10.98:8080",
     “groups”: [
	    {
            	"ID": 1234657,
            	"TYPE" : ”RFID"
	    },
	    {
		"ID": 87654428,
		"TYPE" : “ENTRY"
	    }
    ]
}
```

**Формат ответа:**
```sh
{
    "group_id": уникальный идентификатор группы, long,
}
```
HTTP Status 200 - в случае успешной регистрации,
HTTP Status 400 - в случае неудачной регистрации.

### Создание новой RFID метки - `POST /api/create` - запрос с платы на сервер
Метод для создания и регистрации в базе новой RFID метки.

**Список параметров:**
`@RequestParam {Long rfidLabel}` - уникальный номер, записанный в RFID метку

**Формат ответа:**
HTTP Status 201

**Возможные ошибки**
При неудачном создании RFID метки (если метка уже существует) HTTP Status 409, при передаче неправильного формата данных - HTTP Status 400, в случае неисправности сервера - HTTP Status 500.

### Получение эвента о чтении RFID метки - `POST /api/event` - запрос с платы на сервер

Метод в который нужно посылать событие после скана RFID метки. Тело события должно содержать информацию зашитую в RFID метку и ID устройства с которого пришел эвент. ID устройства должно содержать в себе один из двух возможных параметров, чтобы можно было понять с какого устройства пришел эвент.

**Список параметров:**
`@RequestBody RfidLabel` - объект содержащий 2 поля:
device_id - идентификатор устройства,
rfid - уникальный номер, содержащийся в RFID метке.

**Формат запроса:**
```sh
{
    "device_id": уникальный идентификатор устройства, long,
    "rfid": 1234213723817292
}
```

**Формат ответа**
HTTP Status 200

**Возможные ошибки:**
В случае попытки несанкционированного доступа будет приходить HTTP Status 401, в случае неисправности сервера - HTTP Status 500.

### Принудительное открытие ворот - `POST /forceOpen` - запрос с сервера на плату

Метод для принудительного открытия шлагбаума в случае ошибок сканирования или других неисправностей. На плату будет отправлена строка "Force open", после которой плата должна открыть шлагбаум.

**Формат запроса:**
```sh
{
    "device_id": уникальный идентификатор устройства, long,
}
```

**Формат ответа:**
HTTP Status 200

**Возможные ошибки**
При отсутсвии или недоступности данного шлагбаума среди зарегистрированных устройств HTTP Status 404, при недоступности сервера HTTP Status 500.

### Сообщение о критической ошибке модуля - `POST /api/report` - запрос с платы на сервер
Метод предназначенный для сообщения в приложение о критических ошибках работы шлагбаума или считывателя RFID меток.
В данный метод нужно посылать запрос до получения статуса 200, чтобы убедиться в том, что наш сервер узнал о критической ошибке какого либо устройства.

**Список параметров:**
```sh
{
    "address" :  "192.168.10.98:8080",
    "device_id": уникальный идентификатор устройства, long
}
```

**Формат ответа:**
HTTP Status 200 - в случае успешного получения сервером информации.

**Возможные ошибки**
В случае недоступности сервера HTTP Status 500.

---
Примечания: Если в ответ на запрос получен статус 500, то рекомендуется сделать еще несколько попыток запроса.
